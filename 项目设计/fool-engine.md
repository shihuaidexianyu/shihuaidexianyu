### 1. 项目目的

“Fool Engine”项目旨在创建一个商品交易引擎，专注于模拟社会经济运转所必需的基础物资交易。它的核心目标不是构建一个用于真实金融交易的系统，而是成为一个能够模拟和推演宏观经济动态的工具。

项目通过模拟以下几类核心商品的供需和价格波动，来直观展示真实世界的经济现象：

- **能源**: 如原油（OIL/#）、天然气（GAS/#）。
    
- **农产品**: 如小麦（WHEAT/#）、玉米（CORN/#）。
    
- **工业金属**: 如铜（COPPER/#）、铁矿石（IRON/#）。
    
- **贵金属**: 如黄金（GOLD/#）。
    

该模拟器可以展示不同类型的市场参与者（如生产者、消费者、投机者）的行为，并能反映真实世界的宏观事件（如地缘政治冲突、自然灾害、技术突破等）如何对基础物资的供需平衡和价格产生影响。

### 2. 技术栈

该项目后端完全基于 **Rust** 语言构建，保证了高性能和内存安全。其技术栈遵循“YAGNI”（You Ain't Gonna Need It）原则，保持了单体架构的简洁性，没有引入复杂的外部依赖。

- **核心框架**:
    
    - **Tokio**: 作为异步运行时，为系统提供了强大的并发处理能力。
        
    - **Axum**: 一个基于 Tokio 的现代化 Web 框架，用于构建 REST API 接口。
        
    - **Tower**: 用于构建健壮网络服务和客户端的模块化库，Axum 建立在此之上。
        
- **数据处理与序列化**:
    
    - **Serde**: Rust 生态中最流行的数据序列化/反序列化框架，用于处理 JSON 等格式。
        
    - **rust_decimal**: 用于进行高精度的十进制数运算，避免了使用浮点数在金融计算中可能出现的精度问题。
        
    - **UUID**: 用于为订单、用户等实体生成唯一的标识符。
        
    - **Chrono**: 用于处理日期和时间。
        
- **配置管理**:
    
    - **TOML**: 用于解析 `.toml` 格式的配置文件，如 `config/system.toml`。
        
    - **Dotenvy**: 用于从 `.env` 文件加载环境变量。
        
- **日志与调试**:
    
    - **Tracing**: 一个功能强大的框架，用于检测 Rust 程序以收集结构化的、基于事件的诊断信息。
        

### 3. 设计文档

项目的设计理念是“简单优先”和“有机生长”，从一个清晰、扁平的单体应用开始，让架构随着业务需求自然演进。

#### 3.1 核心架构

系统采用单体架构，主要模块包括：

- **交易核心 (`trading`)**: 包含交易引擎、订单簿、订单和市场数据的定义。是整个系统的枢纽。
    
- **API 接口 (`api`)**: 基于 Axum 的 RESTful 接口，作为系统与外部客户端（如演示脚本、AI 客户端）交互的窗口。
    
- **账户管理 (`portfolio`)**: 负责管理用户账户、现金余额和商品持仓。
    
- **时钟服务 (`clock`)**: 一个独立的服务，用于生成统一的时间戳，确保交易的可重现性和一致性。
    
- **系统市场制造者 (`system_market_maker`)**: 系统的核心特色功能，负责提供初始流动性并根据市场状况动态定价。
    
- **商品与事件系统 (`commodities`, `commodity_events`, `market_events`)**: 定义了可交易的商品，并模拟生成影响市场的各类真实世界事件。
    

#### 3.2 关键设计决策

1. 独立时钟服务 (Clock Service)
    
    不直接使用系统时间，而是启动一个独立服务，以固定的间隔（如 100ms）产生“滴答”（tick）信号。所有订单创建和交易撮合都使用此时钟信号附带的时间戳。
    
    - **优点**:
        
        - **可重现性**: 交易序列可以基于滴答计数进行精确回放和测试。
            
        - **一致性**: 系统内所有组件共享唯一的时间源。
            
        - **可控性**: 可以通过调整时钟速度来加速或减速模拟。
            
2. 系统市场制造者 (System Market Maker)
    
    系统中存在一个特殊的“系统用户”（ID 固定为 00000000-...），它在启动时就拥有所有商品的初始库存。
    
    - **作用**:
        
        - **提供初始流动性**: 确保任何时候用户都有交易对手方，可以从系统中买入商品或向系统卖出商品。
            
        - **动态定价**: 系统的买卖报价不是固定的，而是根据一系列因素动态调整，模拟真实市场的价格发现机制。
            
3. 动态定价机制
    
    系统市场制造者的定价模型综合考虑了多个因素：
    
    - **库存水平**: 当系统库存低于预设的“最小库存”时，会自动提高售价；高于“最大库存”时，则会降低售价。
        
    - **市场事件**: 由 `MarketEventManager` 模块随机生成的事件（如供应中断、需求激增）会带来一个价格冲击系数，直接影响报价。
        
    - **基础利润率**: 系统的买卖报价之间始终维持一个合理的价差（margin），以模拟真实做市商的利润。
        
    - **价格弹性**: 配置文件中为每种商品定义了“价格弹性”系数，决定了价格对库存变化的敏感度。
        
4. **账户与持仓管理**
    
    - **原子性**: 用户的资金和持仓检查、交易撮合、以及交易后的账户状态更新都在一个受并发保护（`RwLock`）的事务中完成，保证了操作的原子性。
        
    - **严格检查**:
        
        - 下买单时，会检查用户是否有足够的现金（对于市价单，会基于当前最优卖价估算所需资金）。
            
        - 下卖单时，会检查用户是否有足额的商品持仓。
            

### 4. 具体实现

#### 4.1 交易引擎 (`TradingEngine`)

作为系统核心，`TradingEngine` 在一个 `RwLock` 内部维护了系统的所有状态，包括所有用户的投资组合 (`portfolios`)、所有订单 (`orders`) 和订单簿 (`orderbook`)。当收到一个下单请求时，它会执行以下流程：

1. **用户验证**: 检查下单的用户 ID 是否存在于 `portfolios` 哈希表中。
    
2. **资金/持仓检查**: 根据订单是买入还是卖出，调用 `Portfolio` 模块的方法检查用户的现金或商品头寸是否充足。
    
3. **创建对手单**: 如果是普通用户的订单，系统市场制造者会立即创建一个方向相反的“对手单”（Counter Order），其价格由动态定价机制决定。
    
4. **订单撮合**: 将用户订单和系统对手单依次送入 `OrderBook` 进行撮合。
    
5. **处理成交**: 如果撮合成功，`process_trade` 方法会被调用，以原子方式更新买卖双方的现金和持仓。
    

#### 4.2 订单撮合 (`OrderBook`)

撮合引擎的实现非常高效和简洁：

- 它内部使用两个 `BTreeMap`（一种有序的哈希表）来分别存储买单（bids）和卖单（asks）。
    
- 买单按价格从高到低排序，卖单按价格从低到高排序。这使得获取最优买价（`best_bid`）和最优卖价（`best_ask`）的操作非常迅速。
    
- **市价单 (Market Order)**: 买单会立即与订单簿中价格最低的卖单成交；卖单则与价格最高的买单成交。
    
- **限价单 (Limit Order)**: 如果一个限价单无法立即与对手方成交（例如，买价低于最低卖价），它将被直接存入订单簿中，等待后续的对手单来匹配。
    

#### 4.3 事件驱动系统

系统通过 `MarketEventManager` 模块实现事件驱动。

1. 该管理器以固定的时间间隔（例如 30 秒）运行。
    
2. 每次运行时，它会调用 `CommodityEventGenerator` 来根据预设的概率和规则生成一个随机的商品事件。
    
3. `CommodityEventGenerator` 内部定义了大量现实世界的事件模板，如不同地区、不同严重程度的供应中断，或不同原因导致的需求激增等。
    
4. 生成事件后，管理器会调用交易引擎的 `handle_market_event` 方法。
    
5. 交易引擎将事件传递给 `SystemMarketMaker`，后者会更新内部的“事件影响因子”，这个因子将在下一次价格更新时被纳入计算，从而实现事件对市场价格的传导。
    

这个项目通过这些精心设计的功能模块，成功地创建了一个既简单又功能强大的商品交易模拟环境。