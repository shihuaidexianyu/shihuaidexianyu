## JWT

### 什么是 JWT？

JWT，全称是 **JSON Web Token**，是一种开放标准 (RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息。这些信息会经过数字签名，因此可以被验证和信任。

把它想象成一个带有防伪标识的数字身份证。这个身份证包含了持有人的基本信息，并且由于有防伪标识（签名），接收方可以很方便地验证这个身份证是不是伪造的。

### JWT 的结构

一个 JWT 实际上是一个由三部分组成的字符串，这三部分由点 (`.`) 分隔开来，格式如下：

`xxxxx.yyyyy.zzzzz`

这三部分分别是：

1.  **标头 (Header)**
2.  **载荷 (Payload)**
3.  **签名 (Signature)**

-----

#### 1\. 标头 (Header)

标头部分通常由两部分组成：

  * **令牌的类型 (typ)**：也就是 `JWT`。
  * **所使用的签名算法 (alg)**：例如 `HS256` (HMAC SHA-256) 或 `RS256` (RSA SHA-256)。

这个 JSON 对象会经过 Base64Url 编码，形成 JWT 的第一部分。

**示例：**

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

编码后就变成了 `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`。

-----

#### 2\. 载荷 (Payload)

载荷部分包含了要传递的数据，这些数据被称为**声明 (Claims)**。声明是关于实体（通常是用户）和其他数据的陈述。声明有三种类型：

  * **注册声明 (Registered Claims)**：这是一些预定义的声明，建议使用但不是强制性的。例如：
      * `iss` (Issuer)：签发者
      * `sub` (Subject)：主题（通常是用户的 ID）
      * `aud` (Audience)：接收者
      * `exp` (Expiration Time)：过期时间
      * `iat` (Issued At)：签发时间
  * **公共声明 (Public Claims)**：这些可以由使用 JWT 的人随意定义，但为了避免冲突，应该在 [IANA JSON Web Token Registry](https://www.google.com/search?q=https://www.iana.org/assignments/json-web-token/json-web-token.xhtml) 中定义它们，或者为其附加一个命名空间。
  * **私有声明 (Private Claims)**：这是在签发者和接收者之间共享的、既非注册声明也非公共声明的自定义声明。常用于传递一些非标准化的信息。

**重要提示：** 载荷部分只是进行了 Base64Url 编码，**并没有加密**。这意味着任何人都可以解码并读取其中的内容。因此，**绝对不要在载荷中存放任何敏感信息**，比如用户的密码。

**示例：**

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1516239022
}
```

编码后就变成了 `eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0`。

-----

#### 3\. 签名 (Signature)

签名部分是 JWT 安全性的核心。要创建签名，你需要将以下三者结合起来：

1.  编码后的标头 (Encoded Header)
2.  编码后的载荷 (Encoded Payload)
3.  一个**密钥 (Secret)**

然后使用标头中指定的算法（例如 HS256）进行签名。

**计算公式：**

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

这个签名的作用是**验证信息的完整性和来源**。当服务器收到一个 JWT 时，它会使用自己保存的密钥，按照同样的方式重新计算一次签名。如果计算出的签名与 JWT 中附带的签名一致，就说明：

  * **数据未被篡改**：因为哪怕载荷中有一个字符被修改，重新计算出的签名也会完全不同。
  * **令牌确实是由可信方签发的**：因为只有拥有密钥的人才能生成正确的签名。

### JWT 是如何工作的？ (认证流程)

JWT 最常见的应用场景是用户认证。流程如下：

1.  **用户登录**：用户使用用户名和密码向服务器发送登录请求。
2.  **服务器验证**：服务器验证用户的凭据是否正确。
3.  **签发 JWT**：如果验证成功，服务器会创建一个包含用户ID等信息的 JWT，并用自己的密钥对其进行签名，然后将这个 JWT 返回给客户端（通常是浏览器）。
4.  **客户端存储 JWT**：客户端收到 JWT 后，通常会将其存储在本地（例如 Local Storage 或 Cookie）。
5.  **后续请求**：当客户端需要访问受保护的资源时（例如获取用户资料），它会在请求的 `Authorization` 标头中附带上这个 JWT，通常使用 `Bearer` 模式：
    ```
    Authorization: Bearer <token>
    ```
6.  **服务器验证 JWT**：服务器收到请求后，会检查 `Authorization` 标头中的 JWT。它会首先验证签名是否有效。如果签名有效，服务器就可以信任这个令牌中的信息（例如用户ID），并根据这些信息来授权用户的请求，而**无需再次查询数据库来验证用户身份**。

### JWT 的优点

  * **无状态和可扩展性 (Stateless & Scalable)**：服务器端不需要存储任何 session 信息。每个请求都包含了所有必要的用户信息，这使得系统更容易横向扩展。任何一台服务器只要拥有密钥，就能验证令牌。
  * **紧凑 (Compact)**：由于其较小的体积，JWT 可以通过 URL、POST 参数或者 HTTP 头部发送。
  * **自包含 (Self-contained)**：载荷中包含了所有必要的用户信息，避免了多次查询数据库。
  * **跨域友好**：与传统的基于 Cookie 的 session 认证不同，JWT 可以轻松地用于跨域资源共享 (CORS)。

### JWT 的缺点和注意事项

  * **无法主动失效**：一旦 JWT 被签发，在它过期之前都会有效。如果用户的令牌在此期间被盗，攻击者就可以一直使用它。解决方案通常包括：
      * 设置较短的过期时间。
      * 使用刷新令牌 (Refresh Token) 机制。
      * 维护一个黑名单，记录已失效的令牌（但这又违背了“无状态”的初衷）。
  * **安全性依赖于密钥**：密钥的保密至关重要。一旦密钥泄露，攻击者就可以伪造任何用户的令牌。
  * **载荷内容是公开的**：切记不要在载荷中存放敏感信息。

### JWT 实例

假设我们在用户登录成功后，收到了下面这一长串 JWT 字符串：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsIm5hbWUiOiLlvKDkuIkiLCJpYXQiOjE2NTQwMDYwMjIsImV4cCI6MTY1NDAwOTYyMn0.yadF0kN4mr_J6JjBgg484Z_cdc3g3T5NnGe3Jz-p_5A
```

这个字符串由三个部分组成，用点 `.` 连接。

`第一部分` . `第二部分` . `第三部分`

-----

#### 第一部分：标头 (Header)

**原始编码字符串:**
`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

这是经过 Base64Url 编码后的结果。我们把它解码后，会得到以下 JSON 对象：

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**作用解释:**

这部分就像是这个 JWT 的“说明书”或“封面”。它告诉接收方：

  * `"alg": "HS256"`：**签名算法 (Algorithm)**。这说明JWT的第三部分（签名）是使用 `HS256` (HMAC-SHA256) 算法生成的。服务器在验证签名时，也必须使用同样的算法。
  * `"typ": "JWT"`：**令牌类型 (Type)**。这指明了这是一个 `JSON Web Token`。

所以，这部分的作用就是**声明类型和签名方法**。

-----

#### 第二部分：载荷 (Payload)

**原始编码字符串:**
`eyJzdWIiOiIxMjM0NSIsIm5hbWUiOiLlvKDkuIkiLCJpYXQiOjE2NTQwMDYwMjIsImV4cCI6MTY1NDAwOTYyMn0`

同样，我们对它进行 Base64Url 解码，得到以下 JSON 对象：

```json
{
  "sub": "12345",
  "name": "张三",
  "iat": 1654006022,
  "exp": 1654009622
}
```

**作用解释:**

这部分是 JWT 的“内容”或“身份证信息”，它包含了需要传递的具体数据。

  * `"sub": "12345"`：**主题 (Subject)**。这通常是用户的唯一标识符，比如数据库里的用户ID。服务器可以根据这个ID知道是哪个用户在操作，而不需要再次查询数据库。
  * `"name": "张三"`：**姓名 (Name)**。这是一个自定义的声明，用于存放用户的名字。方便服务器直接获取并使用，比如显示“欢迎，张三！”。
  * `"iat": 1654006022"`：**签发时间 (Issued At)**。这是一个Unix时间戳，记录了该 JWT 是在什么时候被创建的。
  * `"exp": 1654009622"`：**过期时间 (Expiration Time)**。这也是一个Unix时间戳，记录了该 JWT 将在什么时候失效。在这个例子中，它将在签发后一小时（3600秒）过期。服务器收到这个 JWT 时，必须检查当前时间是否已经超过了 `exp` 时间，如果超过了，就必须拒绝该请求。

所以，这部分的作用就是**携带用户信息和有效期限等核心数据**。

-----

#### 第三部分：签名 (Signature)

**原始字符串:**
`yadF0kN4mr_J6JjBgg484Z_cdc3g3T5NnGe3Jz-p_5A`

**作用解释:**

这部分是 JWT 的“防伪标识”，它保证了前两部分的信息没有被任何人篡改。

它的生成过程如下：

1.  取出编码后的第一部分（Header）和第二部分（Payload）。
    `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsIm5hbWUiOiLlvKDkuIkiLCJpYXQiOjE2NTQwMDYwMjIsImV4cCI6MTY1NDAwOTYyMn0`
2.  准备一个只有服务器自己知道的**密钥 (Secret)**。我们假设密钥是 `my-super-secret-key`。
3.  使用在 Header 中声明的 `HS256` 算法，将第一步的字符串和第二步的密钥进行加密计算。

<!-- end list -->

```javascript
// 伪代码
HMACSHA256(
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsIm5hbWUiOiLlvKDkuIkiLCJpYXQiOjE2NTQwMDYwMjIsImV4cCI6MTY1NDAwOTYyMn0",
  "my-super-secret-key"
)
```

这个计算的结果，就是第三部分的签名字符串。

当服务器收到这个完整的 JWT 后，它会：

1.  自己拿出保存的密钥 `my-super-secret-key`。
2.  用完全相同的算法，对接收到的 JWT 的前两部分重新计算一次签名。
3.  对比自己算出来的签名和收到的 JWT 的第三部分是否**完全一致**。

<!-- end list -->

  * 如果一致，说明这个 JWT 是可信的：数据没有被中途修改，并且确实是由持有正确密钥的源头签发的。
  * 如果不一致，说明数据被篡改过，或者签发者是伪造的。服务器会立刻拒绝这个请求。

所以，这部分的核心作用就是**保证数据的完整性和真实性**。

#### 总结
通过这个例子，我们可以清晰地看到 JWT 的各个部分是如何协同工作的：

  * **Header** 告诉我们 “怎么读” 这个 JWT。
  * **Payload** 告诉我们 “内容是什么”。
  * **Signature** 向我们保证 “内容是真的，没被改过”。

三者结合，就构成了一个紧凑、安全、自包含的信息凭证。

## Base64Url
为了完全理解 Base64Url，我们首先要明白它的基础——标准的 Base64 编码。

### 1. 什么是 Base64？

**核心思想**：Base64 是一种将任意**二进制数据**转换成由64个可打印字符组成的文本字符串的编码方法。

你可能会问，为什么需要这种转换？

因为在互联网早期，很多协议或系统（比如电子邮件、HTTP协议的某些部分）只能处理纯文本（ASCII字符），无法直接传输图片、音频或包含特殊符号的二进制数据。Base64 就是为了解决这个问题而生的，它能将这些二进制数据“翻译”成安全的纯文本格式，以便顺利传输。

**如何工作（简化版）**：
1.  它将每3个字节（3 * 8 = 24位）的二进制数据作为一组。
2.  然后将这24位数据划分为4个6位的单元（4 * 6 = 24位）。
3.  每个6位的单元可以表示 $2^6 = 64$ 个不同的值（0-63）。
4.  这64个值分别对应一个固定的字符。这个字符集包含了大小写字母、数字，以及两个特殊符号 `+` 和 `/`。
5.  如果原始数据凑不够3个字节，会在末尾用 `=` 符号进行**填充 (Padding)**，以确保最终的字符串长度是4的倍数。

**标准 Base64 字符集 (64个字符):**
* `A-Z` (26个)
* `a-z` (26个)
* `0-9` (10个)
* `+` (第62个字符)
* `/` (第63个字符)
* **填充符:** `=`

---

### 2. 为什么需要 Base64Url？

我们看到了，标准的 Base64 包含了三个特殊字符：`+`、`/` 和 `=`。

这些字符在某些场景下会引发严重的问题，尤其是在 **URL 地址** 和 **文件名** 中：

* **`+` (加号)**: 在 URL 的查询字符串中，加号通常被解释为空格。例如，`?name=a+b` 可能会被服务器解析为 `name="a b"`，导致数据失真。
* **`/` (斜杠)**: 在 URL 路径中，斜杠是路径分隔符。例如，`.../part1/part2/...`。如果编码结果中含有 `/`，会扰乱 URL 的结构。同样，在文件名中它也是路径分隔符。
* **`=` (等号)**: 虽然 `=` 在 URL 中是允许的，但它在查询字符串中是用来分隔键和值的特殊字符（如 `key=value`），在某些系统或应用中可能会被错误地处理或编码，引发歧义。

为了在 URL 和文件名这类环境中安全地使用 Base64 编码，**Base64Url** 应运而生。

---

### 3. Base64Url 是什么？

**Base64Url** 是 Base64 的一个变种，它专为在 URL 和文件名中使用而设计，其目标就是变得“URL安全” (URL-safe)。

它的改动非常简单，只有两点：

1.  **替换特殊字符**：
    * 将标准 Base64 中的 `+` 替换成 `-` (减号)。
    * 将标准 Base64 中的 `/` 替换成 `_` (下划线)。

2.  **移除填充符**：
    * 将末尾的 `=` 填充符**全部移除**。因为解码器通常可以根据字符串的长度推断出原始数据的长度，所以填充符不是必需的。这使得编码后的字符串更简洁。

**Base64Url 字符集 (64个字符):**
* `A-Z` (26个)
* `a-z` (26个)
* `0-9` (10个)
* `-` (代替了 `+`)
* `_` (代替了 `/`)
* **填充符:** 无

---

### 4. 举例说明

我们用一个包含特殊字符的二进制数据来演示这个过程。

假设我们要编码的文本是 `"\xFB\xFF\xBE"` (这是三个在二进制表示中会产生 `+` 和 `/` 的字节)。

1.  **标准 Base64 编码**
    * 编码过程会产生索引值 `62`、`63` 和 `63`。
    * 在标准 Base64 中，`62` 对应 `+`，`63` 对应 `/`。
    * 结果是: **`+/+`**

2.  **Base64Url 编码**
    * 同样的过程，产生索引值 `62`、`63` 和 `63`。
    * 在 Base64Url 中，`62` 对应 `-`，`63` 对应 `_`。
    * 结果是: **`-_`**

现在，想象一下把这两个结果放到 URL 里：

* `https://example.com/data/+/+`  <-- **可能会出错！** 浏览器或服务器可能无法正确解析。
* `https://example.com/data/-_`   <-- **安全！** `-` 和 `_` 都是 URL 和文件名中的安全字符。

**在 JWT 中的应用**

回到我们之前讨论的 JWT，它的结构是 `header.payload.signature`。其中 header 和 payload 都是 JSON 对象，它们需要被编码成字符串。如果使用标准 Base64，产生的字符串中就可能含有 `+` 或 `/`，当这个 JWT 作为 URL 参数传递时（例如 `https://site.com/auth?token=xxxx.yyyy.zzzz`），就会出问题。

因此，**JWT 规范强制要求必须使用 Base64Url** 对 Header 和 Payload 进行编码，以确保 JWT 无论是在 HTTP 头部、POST 请求体中，还是在 URL 中传递，都是安全和可靠的。

**总结:**

**Base64Url 就是一个对标准 Base64 小修小补后的“安全版”，它通过替换 `+` 和 `/`，并移除 `=`，使得编码后的字符串可以被安全地放在 URL 或文件名中，而不会引起任何歧义或错误。**
## 反射机制 (`Reflection`)

#### (1) 核心思想

想象一下，您不是在编写代码，而是在建造一座由各种不同功能的房间（对象、类、函数）组成的建筑。

**没有反射机制**，程序一旦运行起来（建筑建成并投入使用），它内部的每个房间对自己和他人的信息是一无所知的。`A` 房间不知道隔壁 `B` 房间有多大，由什么材料构成，甚至不知道它的存在，除非在建造时就用“硬编码”的方式将 `B` 的信息写死在 `A` 的设计图里。

**有了反射机制**，就如同给这座建筑装上了一套智能管理系统。任何一个房间或系统本身，在运行时都可以随时查询：
* **“我是谁？”** (获取自身的类型信息，如类名 `User`)
* **“我由什么组成？”** (获取自身的所有属性/字段，如 `id`, `username`, `email`)
* **“我的每个部分有什么特点？”** (获取每个字段的类型，如 `id` 是整数，`username` 是字符串，以及是否有特殊标记如“主键”、“不可为空”等)
* **“我能做什么？”** (获取自身的所有方法，如 `changePassword()`)

简单来说，**反射是程序在运行时（Runtime）检查、探知和修改自身状态或行为的能力。** 它是元编程 (Metaprogramming) 的一种核心形式，即用代码来操作代码。

#### (2) 在 Web 开发中的典型应用

在 Web 开发的后端服务中，反射几乎无处不在，是许多高级框架和库的基石：

* **ORM (对象关系映射)**：像 Java 的 Hibernate、Python 的 SQLAlchemy、Go 的 GORM 或 Node.js 的 TypeORM。当您定义一个 `class User` 并希望将其存入数据库时：
    * ORM 库通过**反射**读取 `User` 类的结构：有哪些字段 (`id`, `name`)，每个字段是什么类型 (`int`, `string`)，以及您添加的注解 (`@PrimaryColumn`, `@Column`)。
    * 基于这些元数据，它能自动生成 `CREATE TABLE users (...)` 的 SQL 语句，以及 `SELECT`, `INSERT`, `UPDATE` 等操作，将数据库的行记录与您的 `User` 对象进行双向转换。您无需手动编写繁琐的 SQL。

* **JSON 序列化/反序列化**：当您的后端 API 收到一个 JSON 请求体 `{"id": 123, "name": "alice"}` 时：
    * 框架（如 Java 的 Jackson，C# 的 Newtonsoft.Json）使用**反射**来查找目标 `User` 类。
    * 它会遍历类的所有字段，然后去 JSON 中寻找同名字段，并进行类型检查和赋值，自动将 JSON 字符串实例化为一个 `User` 对象。反之，当您返回一个 `User` 对象时，它也能通过反射将其转换为 JSON 字符串。

* **依赖注入 (Dependency Injection)**：在大型应用中，一个服务（如 `OrderService`）可能依赖其他服务（`PaymentService`, `InventoryService`）。
    * DI 框架（如 Java Spring, NestJS）在启动时，会通过**反射**检查 `OrderService` 的构造函数，发现它需要 `PaymentService` 和 `InventoryService` 类型的参数。
    * 框架会自动创建这些依赖的实例，并“注入”到 `OrderService` 中。这极大地降低了代码的耦合度。

* **API 文档自动生成**：像 Swagger/OpenAPI 这样的工具，可以集成到您的 Web 框架中。
    * 它们通过**反射**扫描您编写的 API 端点函数（如 `get_user_by_id(user_id: int)`）。
    * 它们能提取出路由路径 (`/users/{id}`), HTTP 方法 (`GET`), 参数 (`user_id` 是整数), 以及返回类型 (`User` 对象)。
    * 最终，它将这些通过反射收集来的元数据，汇编成一份标准的 `openapi.json` 文档。这与您的 `AnnotatedRouter` 收集 `Vec<ApiEndpoint>` 的原理异曲同工。

---

## 代码生成 (`Codegen`)

#### (1) 核心思想

如果说反射是从“现有代码”中提炼出“结构化数据（元数据）”，那么代码生成则是一个相反的过程：**它从“结构化数据”出发，自动地、有规律地创造出“新的代码”**。

它是一个强大的自动化工具，本质上是一个“写代码的程序”。这个程序接收一些输入（通常是某种形式的配置文件、模板或元数据），然后输出可以直接被编译或解释执行的源代码文件。

#### (2) 在 Web 开发中的典型应用

代码生成在整个 Web 开发工作流中都扮演着“效率放大器”的角色：

* **API 客户端/SDK 生成 (最核心的应用)**：这是解决前后端协作痛点的“银弹”。
    * **输入**：一份机器可读的 API 契约，例如由上一节反射生成的 `openapi.json` 文件，或是手写的 GraphQL Schema。
    * **过程**：使用一个代码生成工具（如 OpenAPI Generator, gRPC-Web, Apollo Codegen）。
    * **输出**：为前端生成一个完整的 `api.ts` 或 `sdk.js` 文件。这个文件包含了：
        * 所有数据模型的 TypeScript `interface` 或 `type`。
        * 每一个 API 端点对应的、完全类型化的异步函数，如 `async function getUserById(userId: number): Promise<User>`。函数内部封装了 `fetch` 请求、URL 构建、参数序列化等所有细节。

* **GraphQL 生态**：GraphQL 是将代码生成运用到极致的典范。
    * **输入**：一个 `schema.graphql` 文件，它定义了所有可用的数据类型和查询。
    * **输出**：
        * **前端**：生成所有 TypeScript 类型定义，以及与 React/Vue 等框架集成的、类型安全的 Hooks（如 `useUserQuery`）。
        * **后端**：可以为 Java, Python 等语言生成解析器 (Resolver) 的骨架代码，开发者只需填充业务逻辑。

* **数据库交互代码生成**：一些 ORM 或数据库工具可以更进一步。
    * **输入**：一个数据库 schema，或者一个定义模型的配置文件。
    * **输出**：直接生成所有数据表的 `class` 定义代码，以及基础的 CRUD (Create, Read, Update, Delete) 操作函数。

* **项目脚手架**：像 `create-react-app`, `Vite`, `Angular CLI` 或 `NestJS CLI`。
    * **输入**：简单的命令行指令 (`npx create-react-app my-app`)。
    * **输出**：一个包含完整项目结构、配置文件、示例代码和最佳实践的即用型项目文件夹。

---

## 反射和代码生成的协同

在现代 Web 开发中，反射和代码生成联手打造了一个高度自动化、类型安全、且沟通成本极低的前后端协作流程。

**后端是唯一的“事实来源” (Single Source of Truth)**

1.  **定义 (Define)**：后端开发者在他们最熟悉的语言（Rust, Go, Java, Python...）中定义数据结构 (structs/classes) 和 API 接口。这是所有逻辑的起点和唯一权威。

2.  **反射 (Reflect)**：在编译时或运行时，后端框架利用 **反射机制** 扫描这些代码，将其转换成一份语言无关的、结构化的 **API 元数据**（例如，一个内部的 `Vec<ApiEndpoint>` 列表，或者一个公开的 `openapi.json` 文件）。

3.  **生成 (Generate)**：一个 **代码生成** 工具读取这份元数据。

4.  **消费 (Consume)**：该工具为前端（通常是 TypeScript）生成一个完整的、类型安全的 API SDK。

这个流程形成了一个完美的闭环：

`后端 Rust/Java/Go 代码` ➔ `[反射]` ➔ `API 元数据 (OpenAPI/GraphQL Schema)` ➔ `[代码生成]` ➔ `前端 TypeScript SDK`

**最终带来的巨大优势：**

* **极致的类型安全**：后端对 API 的任何改动（如修改字段名、增删字段、改变类型），都会在前端的下一次代码生成后，立刻以 TypeScript 编译错误的形式体现出来。这消除了几乎所有因前后端信息不匹配导致的运行时 Bug。
* **自动化和效率**：前端开发者无需再手动维护 API 请求代码和数据模型，也无需频繁查阅或质疑 API 文档。后端更新后，只需运行一个命令，所有变更自动同步。
* **清晰的契约和解耦**：生成的元数据（如 `openapi.json`）成为了前后端之间一个不可否认的、机器可读的“契约”，使得团队可以并行开发，互不阻塞。
