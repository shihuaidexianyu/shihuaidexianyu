### **MyHelper: 轻量化自包含的异步智能任务平台 (含Web可视化界面)**

**版本**: 0.1.0
**核心理念**: 一个通过**开放访问的Web界面**进行可视化监控与配置，能够**自动生成结构化报告并允许自定义CSS样式**，通过**多渠道主动推送**结果，无需外部数据库、通过分层Agent协作并调用外部MCP服务来完成任务的、持久化且健壮的异步任务处理系统。

### **第一章：系统概述与设计原则**

#### **1.1 系统定位**

`MyHelper` 是一个设计为在单个应用进程中独立运行的智能自动化平台。它通过一个集成的、无需登录的Web界面提供任务的可视化监控、手动触发和系统配置能力。其核心是一个**智能任务编排器**，它并非一个直接操作本地资源的编程助理，而是专注于解决复杂的、多步骤的自动化场景，例如：SRE（网站可靠性工程）的应急预案自动化、定期的业务数据分析与报告生成、以及跨多个系统的业务流程整合。

它擅长接收高层次的、人类易于理解的自然语言目标（例如，“查询上周的用户增长数据，如果环比下降超过10%，则拉取相关服务的错误日志，并生成一份分析报告发送给技术主管”），通过内部智能体（Agent）的协同工作，将此目标分解、规划，并最终通过调用一系列预定义的MCP（Master Control Plane）服务来完成任务并交付结果。

#### **1.2 核心设计原则**

- **可视化与可交互性 (Visualization & Interactivity)**: 系统的核心状态，包括任务进度、历史记录和系统配置，都应通过图形化界面直观地展示给用户。这不仅包括任务过程的可视化，也包括**任务结果的可视化报告**。这一原则旨在降低非技术用户的使用门槛，为所有用户提供操作的透明度，并在出现问题时能够快速定位和调试，而不是去翻阅繁杂的后台日志。
    
- **标准化与定制化平衡 (Standardization & Customization Balance)**: 系统提供**标准化的自动报告生成能力**，确保所有任务结果都能以一致、可预测的结构呈现。同时，通过允许用户**注入自定义CSS样式**，来实现视觉上的灵活定制。例如，系统生成的报告HTML结构是固定的（包含标题、摘要、子任务表格等），但用户可以通过提供一个`corporate_theme.css`文件，轻松地将其渲染为带有公司品牌Logo和色调的正式报告，或通过`dark_mode.css`提供更舒适的夜间阅读体验。这达到了开箱即用与个性化需求的完美平衡。
    
- **主动交付 (Proactive Delivery)**: 系统不仅能完成任务，还能根据预设的通知渠道（如邮件、Slack、Webhook）将关键结果和报告链接主动推送给指定的目标。这与传统系统需要用户反复轮询检查任务状态的模式形成鲜明对比，确保了信息的时效性，尤其适用于需要及时响应的告警或关键业务报告场景。
    
- **简洁性 (Simplicity)**: **移除用户登录逻辑**，系统的组件交互和UI操作流程都力求直观、简单。这一设计决策是基于系统部署在受信任内部网络的假设，通过牺牲一定的访问控制安全性，换取了极大的部署和使用便利性。用户无需记忆账号密码，管理员也无需进行复杂的用户权限管理。
    
- **自包含 (Self-Contained)**: 系统的核心功能不依赖外部数据库或消息中间件。这意味着部署`MyHelper`无需预先配置和维护如PostgreSQL、Redis或RabbitMQ等复杂服务。整个应用可以作为一个独立的单元运行，极大地简化了安装、部署和迁移过程，使其能轻松运行在个人开发机、小型服务器甚至资源受限的边缘设备上。
    
- **持久性 (Durability)**: 应用的重启或意外崩溃不会导致已提交任务和核心配置的丢失。所有进行中的任务状态、待处理的任务队列以及系统配置都通过文件系统的形式持久化存储。当应用重启时，它会自动扫描这些文件，恢复到崩溃前的状态，并继续执行未完成的任务，保证了任务处理的可靠性。
    
- **安全性 (Security)**: 假定系统运行在受信任的网络环境中，安全重点在于对MCP服务调用的管控、防止意外的错误配置和提供清晰的操作日志。这意味着系统本身不设防外部网络攻击，但对内部操作的安全性有严格要求，例如，对MCP服务的调用必须通过`ToolManager`进行统一的认证和鉴权。
    
- **健壮性 (Robustness)**: 系统具备容错能力，能够处理工作线程或外部服务调用失败的情况，并支持任务的自动重试机制。例如，当调用MCP服务因网络抖动而超时失败时，系统可以根据预设的策略（如指数退避算法）进行多次重试，从而提高复杂工作流的成功率。
    
- **模块化与可扩展性 (Modularity & Extensibility)**: 系统前后端分离，核心功能模块化。核心的`Worker`逻辑与可插拔的`Agent`、`通知驱动`完全解耦。这种设计使得为系统添加新功能变得异常简单，例如，支持一个新的MCP服务或增加一种新的通知方式，都只需要开发一个独立的模块，而无需改动系统的核心代码。
    

### **第二章：系统架构**

#### **2.1 架构概述**

本系统在逻辑上分为**Web应用层**、**核心服务层**、**持久化层**和**外部依赖**四个部分，它们共同协作，完成从任务接收到最终交付的全过程。

1. **任务的来源与接收**: 系统的入口有两个。一是通过**Web应用层**，用户在浏览器中与Web前端UI交互，手动创建任务或修改系统配置；这些操作通过后端的Web API进入系统。二是后台的**定时触发器(Cron)**，它在预定时间自动创建任务。无论来源如何，所有任务创建的请求最终都会被递交给核心服务层的`MissionManager`。
    
2. **任务的编排与排队**: `MissionManager`接收到请求后，会创建一个唯一的任务（Mission）记录，并立即通知`QueueManager`将该任务ID放入一个持久化的待处理队列中。至此，任务的接收阶段完成，系统可以快速响应前端或触发器。
    
3. **异步执行与智能处理**: 后台工作线程(Worker)是独立于Web应用层的核心引擎。它持续不断地从`QueueManager`中获取待处理的任务。一旦获取成功，它便成为该任务的“所有者”，并驱动其整个生命周期：
    
    - **规划**: Worker首先调用**编排Agent**，该Agent借助**LLMManager**与外部的大语言模型服务通信，将用户的自然语言目标分解为结构化的、带依赖关系的子任务图。
        
    - **执行**: 规划完成后，Worker根据子任务图，调度相应的**专用子Agent**团队来执行具体步骤。子Agent的核心职责是将任务指令转换为对**ToolManager**的调用。
        
    - **外部交互**: **ToolManager**作为系统的唯一出口，负责安全地调用外部的**MCP服务层**来完成实际工作（如查询数据、发送通知等）。
        
    - **报告与渲染**: 当所有核心子任务执行完毕后，Worker进入收尾阶段。如果任务被标记为需要生成报告，Worker将调用**报告生成器(ReportGenerator)**。该组件以编程方式，根据任务的最终数据**自动生成一份结构固定的HTML报告页面**。报告的视觉样式由任务指定的CSS文件来控制。
        
    - **结果推送**: 报告生成后（或跳过此步），如果任务指定了通知方式，Worker将调用**通知管理器(NotificationManager)**，将任务完成的摘要信息以及报告页面的链接，通过一个或多个渠道（如Email、Slack）发送给指定用户。
        
4. **状态持久化**: 在整个过程中，所有任务的详细信息（包括状态、子任务图、结果）由`MissionManager`实时写入**文件系统持久化层**。任务队列的状态由`QueueManager`管理。系统配置由**ConfigManager**管理。这种设计确保了即使应用进程重启，也能从文件中恢复所有任务和配置，继续未竟的工作。
    

#### **2.2 核心组件职责**

- **Web前端 (UI)**
    
    - **职责**: 用户与`MyHelper`系统交互的图形化界面（单页应用）。它负责渲染任务仪表盘、展示任务详情、提供用于修改系统配置的表单，以及让用户手动创建新任务。在创建任务时，它提供**“生成报告”的复选框**，并允许用户**选择一个CSS样式主题**和配置通知方式。任务仪表盘会实时轮询或通过WebSocket更新任务状态。任务详情页会将`subtask_graph`可视化为一个依赖关系图或时间线，清晰展示任务的执行流程。
        
- **Web后端API (BFF - Backend for Frontend)**
    
    - **职责**: 服务于前端UI的专用API层。它托管UI的静态资源，提供开放的、无需认证的RESTful API接口（用于查询/创建任务、获取/更新配置），并额外提供**列出可用CSS样式**的接口（如 `GET /api/styles`）和**访问已生成报告页面**的静态文件服务（如 `GET /results/{mission_id}.html`）。
        
- **配置管理器 (ConfigManager)**
    
    - **职责**: 系统的“配置总管”，对所有可配置项（如定时任务规则、MCP服务信息、通知渠道密钥）进行集中、安全的管理。它提供统一的接口供系统其他部分读取配置，并通过API接收前端传来的新配置，在写入持久化文件前进行严格的合法性校验（例如，校验Cron表达式的语法），并能热加载新配置以避免服务重启。
        
- **报告生成器 (ReportGenerator)**
    
    - **职责**: 系统的“标准化报告构建器”。它接收一个完整的任务数据对象和一个可选的CSS样式文件名，以编程方式**自动生成结构固定的HTML报告**，并在其中链接指定的CSS文件。其生成的HTML结构会包含带有特定class的语义化标签（如 `<header>`, `<main>`, `<footer>`, `<table class="subtasks">`），方便用户编写CSS进行精确的样式控制。
        
- **通知管理器 (NotificationManager)**
    
    - **职责**: 系统的“通讯中心”。它采用驱动模式，内置多种通知驱动（如`EmailDriver`, `SlackDriver`）。它接收格式化的消息和通知配置，根据配置中的`type`字段选择相应的驱动并执行发送操作。这使得添加新的通知渠道（如钉钉、飞书）变得非常简单。
        
- **任务管理器 (MissionManager)**
    
    - **职责**: 任务数据的“管家”，负责所有任务数据文件的原子化创建、读取和更新。它使用文件锁（如`flock`）机制来保证并发操作的安全性，防止多个线程同时写入同一个任务文件而导致数据损坏。
        
- **队列管理器 (QueueManager)**
    
    - **职责**: 持久化任务队列的“调度员”。它通过对文件系统目录的原子性移动操作来模拟一个先进先出的队列，这是一种简单而高效的、无需分布式锁的队列实现方式。
        
- **大语言模型管理器 (LLMManager)**
    
    - **职责**: 与大语言模型（LLM）沟通的“翻译官”，统一管理所有对LLM的API调用，并处理相关的认证、重试和速率限制逻辑。
        
- **工具管理器 (ToolManager / MCP服务网关)**
    
    - **职责**: 系统与外部世界交互的“唯一安全门”，负责安全地调用`MCP服务`。它会从`ConfigManager`中读取相应服务的认证信息（如API Key），并将其附加到出站请求中。
        
- **后台工作线程 (Worker)**
    
    - **职责**: 任务执行的“引擎”和“指挥中心”。它本质上是一个围绕任务状态的状态机，作为Agent的宿主，驱动任务从`PENDING`到`COMPLETED`或`FAILED`的整个生命周期。
        
- **Agent框架**
    
    - **编排Agent (Orchestrator Agent)**: 任务的“总设计师”，负责回答“做什么”和“为什么做”的问题，将用户意图转化为逻辑清晰的计划。
        
    - **专用子Agent (Specialized Sub-Agents)**: 任务的“技术专家团队”，负责回答“怎么做”的问题，将计划中的每一步转化为对`ToolManager`的具体调用。
        
- **文件系统持久化层**
    
    - **职责**: 系统的“记忆体”。通过本地文件和目录，持久化存储所有任务数据、队列状态、系统配置、**CSS样式文件**和**生成的HTML报告**。目录结构清晰，便于手动备份和恢复。
        

### **第三章：核心数据实体：Mission**

`Mission`是系统流转的核心信息载体，它是一个逻辑上的数据结构，记录了一个任务从诞生到终结的所有信息。

- **`mission_id`**: 独一无二的工单编号。
    
- **`natural_language_goal`**: 记录了用户最原始的需求描述。
    
- **`status`**: 标记工单当前的处理阶段，如`待处理`, `规划中`, `执行中`, `报告中`, `渲染中`, `通知中`, `已完成`, `已失败`。
    
- **`subtask_graph`**: 由`编排Agent`生成的最核心的“施工蓝图”。它是一个列表，其中每一项都是一个子任务，包含了`subtask_id`（步骤编号）、`subagent_name`（负责人）、`goal`（步骤描述）、`dependencies`（前置依赖）、`status`（步骤状态）和`result`（步骤结果）等信息。`result`通常是一个JSON对象，包含了MCP服务调用的返回数据。
    
- **`report_config`** (可选, 对象): 用于标记并配置报告生成。如果此字段存在，则任务会生成报告。
    
    - `style`: (字符串, 可选) 要使用的CSS样式文件名，对应`styles/`目录下的文件。如果留空，则使用系统默认样式。
        
- **`notification_config`** (可选, 数组): 一个通知指令的列表，允许推送到多个目标。例如: `[{"type": "email", "to": "manager@example.com", "subject": "Weekly Report Ready"}, {"type": "slack", "channel": "ops-alerts"}]`。
    
- **`result_page_url`** (字符串, 由系统生成): 任务完成后，如果生成了报告，此处会记录报告页面的可访问URL。
    
- **`final_summary`**: 整个任务完成后，由`ReporterAgent`生成的对任务成果的文字总结。
    
- **其他元数据**: 如创建时间、完成时间、触发信息、重试策略等。
    

### **第四章：关键逻辑与工作流程**

#### **4.1 后台任务执行工作流程**

1. **触发与入队**: 一个任务被API或定时器创建，`MissionManager`创建记录，`QueueManager`将其ID放入待处理队列。
    
2. **出队与锁定**: `Worker`线程检测到新任务，通过`QueueManager`以原子操作将其移入“处理中”队列，确保所有权唯一。
    
3. **规划阶段**: `Worker`调用`编排Agent`，后者通过`LLMManager`将任务目标分解为`subtask_graph`。
    
4. **执行阶段**: `Worker`作为项目经理，循环检查`subtask_graph`，找出所有依赖已完成的待执行任务，并将其分发给相应的`专用子Agent`并行或串行地执行。子Agent通过`ToolManager`调用外部MCP服务完成工作，并实时更新结果。
    
5. **报告总结阶段 (Reporting)**: （可选）所有执行步骤完成后，Worker调用`ReporterAgent`，该Agent综合所有子任务的结果，生成`final_summary`文字总结。
    
6. **结果渲染阶段 (Rendering)**: `Worker`检查`Mission`记录中是否存在`report_config`字段。如果存在，它将完整的`Mission`对象和指定的样式文件名传递给`ReportGenerator`，后者自动生成标准结构的HTML内容。`Worker`将此HTML保存到`results/`目录，并更新`Mission`记录中的`result_page_url`。
    
7. **通知推送阶段 (Notifying)**: `Worker`检查是否存在`notification_config`字段。如果存在，它会准备一条包含结果摘要和报告链接的消息，并将其交给`NotificationManager`，由后者通过指定渠道发送。
    
8. **完成与归档**: 所有收尾工作完成后，`Worker`将`Mission`最终状态置为`COMPLETED`，并通知`QueueManager`将其归档。
    

#### **4.2 Web界面交互工作流程**

1. **查看任务状态**: 用户打开Web界面，前端通过`Web后端API`获取任务列表和详情，`Web后端API`则从`MissionManager`读取数据。
    
2. **修改配置**: 用户在UI上修改配置（如Cron表达式）并保存，前端将新配置`POST`到`Web后端API`。后端调用`ConfigManager`来验证并持久化新配置，并触发相关模块热重载。
    
3. **手动触发**: 用户在UI表单中输入自然语言目标。页面提供一个“生成可视化报告”的复选框，勾选后出现一个“报告样式”下拉框（内容由API从`styles/`目录动态获取）。用户还可以配置通知选项。点击提交后，前端将所有信息`POST`到`Web后端API`，后端随即启动后台任务执行流程。
    

### **第五章：非功能性设计**

- **配置管理**
    
    - 系统配置通过`ConfigManager`进行动态管理。`config.json`文件作为配置的持久化载体，需要增加一个新的配置节，用于存放`NotificationManager`所需的密钥和默认设置（如SMTP服务器信息、Slack Bot Token等）。
        
- **日志与监控**
    
    - 系统的每个关键动作（如任务入队、状态变更、API调用）都应产生结构化的日志，并包含`mission_id`，以便于追踪和排错。应提供一个`/health`健康检查接口，暴露关键指标如当前队列长度、活动Worker数量、失败任务总数等，便于接入Prometheus等监控系统。
        
- **安全性**
    
    - **访问控制**: 此设计不包含用户登录和认证逻辑。系统默认所有能访问其Web界面的用户都是可信的，并拥有全部操作权限。因此，`MyHelper`应部署在**安全的、受信任的内部网络**（如公司内网、VPN环境或本地主机）中。**强烈不建议**在没有任何额外安全层（如反向代理认证、IP白名单）的情况下将其直接暴露在公共互联网上。
        
    - **Web安全**: 即使在内网环境，`Web后端API`仍需实现基本的Web安全防护，如防止跨站脚本（XSS），以避免用户无意间提交恶意内容互相影响。
        
    - **配置安全**: `ConfigManager`在写入新配置前必须进行严格的格式和逻辑校验，防止错误的配置导致系统崩溃。
        
- **可扩展性**
    
    - **报告视觉扩展**: 系统的报告视觉风格是高度可扩展的。管理员或开发者**只需向`styles/`目录中添加一个新的CSS文件**，即可为所有用户提供一个新的报告主题选项，无需修改任何代码。
        
    - **报告结构扩展**: 如果需要修改所有报告的HTML结构（例如，增加一个新的数据展示区域），开发者只需修改`ReportGenerator`这一个组件的内部逻辑即可。
        
    - **通知渠道扩展**: 若要支持新的通知渠道（如飞书、钉钉），只需为`NotificationManager`实现一个新的“驱动”类，并在`ConfigManager`中添加相应配置即可，无需改动`Worker`的核心逻辑。